## 코딩 테스트
- https://school.programmers.co.kr/learn/courses/30/lessons/142085

### programmers - 디펜스 게임

- 준호는 요즘 디펜스 게임에 푹 빠져 있습니다. 디펜스 게임은 준호가 보유한 병사 `n`명으로 연속되는 적의 공격을 순서대로 막는 게임입니다. 디펜스 게임은 다음과 같은 규칙으로 진행됩니다.

  - 준호는 처음에 병사 `n`명을 가지고 있습니다.
  - 매 라운드마다 `enemy[i]`마리의 적이 등장합니다.
  - 남은 병사 중 `enemy[i]`명 만큼 소모하여 `enemy[i]`마리의 적을 막을 수 있습니다.
    - 예를 들어 남은 병사가 7명이고, 적의 수가 2마리인 경우, 현재 라운드를 막으면 7 - 2 = 5명의 병사가 남습니다.
    - 남은 병사의 수보다 현재 라운드의 적의 수가 더 많으면 게임이 종료됩니다.
  - 게임에는 `무적권`이라는 스킬이 있으며, `무적권`을 사용하면 병사의 소모없이 한 라운드의 공격을 막을 수 있습니다.
  - `무적권`은 최대 `k`번 사용할 수 있습니다.

- 준호는 `무적권`을 적절한 시기에 사용하여 최대한 많은 라운드를 진행하고 싶습니다.

- 준호가 처음 가지고 있는 병사의 수 `n`, 사용 가능한 무적권의 횟수 `k`, 매 라운드마다 공격해오는 적의 수가 순서대로 담긴 정수 배열 `enemy`가 매개변수로 주어집니다. 준호가 몇 라운드까지 막을 수 있는지 return 하도록 solution 함수를 완성해주세요.

### 제한사항
- 1 ≤ `n` ≤ 1,000,000,000
- 1 ≤ `k` ≤ 500,000
- 1 ≤ `enemy`의 길이 ≤ 1,000,000
- 1 ≤ `enemy[i]` ≤ 1,000,000
- `enemy[i]`에는 i + 1 라운드에서 공격해오는 적의 수가 담겨있습니다.
- 모든 라운드를 막을 수 있는 경우에는 `enemy[i]`의 길이를 return 해주세요.

### 풀이
- `k`가 `enemy`의 수 보다 크거나 같다면 전 라운드 `무적권`을 사용하면 모든 라운드를 막을 수 있기 때문에 `enemy`의 길이 반환
- 그 외의 경우 `enemy`를 순회하며 병사를 소모하고 `answer`증가, `enemy[i]`의 만큼 `우선순위 큐`에 추가
- 소모한 이후 병사의 수가 0보다 작아지면,
- `k`가 0보다 클 경우 -> 이전에 추가한 `enemy[i]`중 가장 큰 값(`우선순위 큐`에서 가장 상단의 값)에서 `무적권`을 사용했다 치고 해당 값만큼 회복 후 진행
- 그 외의 경우 -> 무적권을 모두 소모 했으므로 더 이상 진행 불가로 `answer`를 감소 시키고 `break`하여 반복문 탈출
- 이후 `answer`반환

---

```c++

#include "bits/stdc++.h"

using namespace std;

int solution(int n, int k, vector<int> enemy) {
    int answer = 0;
    
    if(k >= enemy.size())
    {
        return enemy.size();
    }
    
    priority_queue<int> pq;
    
    for(int i = 0; i < enemy.size(); i++)
    {
        int e = enemy[i];
        pq.push(e);
        n -= e;
        answer++;
        
        if(n < 0)
        {
            if(k > 0)
            {
                k--;
                int heal = pq.top();
                pq.pop();
                n += heal;
            }
            else
            {
                answer--;
                break;
            }
        }
    }
    
    return answer;
}

```
